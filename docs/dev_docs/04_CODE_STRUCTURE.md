# Code Structure

This document provides a detailed breakdown of the codebase organization, explaining the purpose of each file and how they interact.

## Directory Tree

```
P3_TB/
â”œâ”€â”€ build/                      # Compiled binaries (generated)
â”‚   â”œâ”€â”€ syscall_server          # RPC server executable
â”‚   â”œâ”€â”€ intercept.so            # Shared library for LD_PRELOAD
â”‚   â”œâ”€â”€ program                 # Test program
â”‚   â””â”€â”€ *.o                     # Object files
â”‚
â”œâ”€â”€ src/                        # Source code
â”‚   â”œâ”€â”€ protocol/               # RPC protocol definition and generated code
â”‚   â”‚   â”œâ”€â”€ protocol.x          # XDR protocol definition (hand-written)
â”‚   â”‚   â”œâ”€â”€ protocol.h          # Generated: structures and constants
â”‚   â”‚   â”œâ”€â”€ protocol_xdr.c      # Generated: XDR serialization functions
â”‚   â”‚   â”œâ”€â”€ protocol_clnt.c     # Generated: client-side RPC stubs
â”‚   â”‚   â””â”€â”€ protocol_svc.c      # Generated: server-side RPC dispatcher
â”‚   â”‚
â”‚   â”œâ”€â”€ intercept/              # Syscall interceptors (headers)
â”‚   â”‚   â”œâ”€â”€ intercept_open.h    # open() and open64() interceptor
â”‚   â”‚   â”œâ”€â”€ intercept_close.h   # close() interceptor
â”‚   â”‚   â”œâ”€â”€ intercept_read.h    # read() interceptor
â”‚   â”‚   â””â”€â”€ intercept_write.h   # write() interceptor
â”‚   â”‚
â”‚   â”œâ”€â”€ rpc_server.c            # RPC server implementation
â”‚   â”œâ”€â”€ rpc_client.c            # RPC client connection manager
â”‚   â”œâ”€â”€ intercept_client.c      # Intercept library entry point
â”‚   â”œâ”€â”€ transport_config.h      # Transport configuration (UNIX/TCP)
â”‚   â””â”€â”€ program.c               # Test program
â”‚
â”œâ”€â”€ docs/                       # Documentation
â”‚   â””â”€â”€ dev_docs/               # Developer documentation
â”‚       â”œâ”€â”€ 00_README.md        # Documentation index
â”‚       â”œâ”€â”€ 01_INTRODUCTION.md  # Project overview
â”‚       â”œâ”€â”€ 02_ARCHITECTURE.md  # System architecture
â”‚       â”œâ”€â”€ 03_ONC_RPC_PRIMER.md# RPC/XDR tutorial
â”‚       â””â”€â”€ ...                 # Additional documentation
â”‚
â”œâ”€â”€ Makefile                    # Build system
â”œâ”€â”€ CLAUDE.md                   # Claude Code project instructions
â””â”€â”€ todo.md                     # Development task list
```

## Source File Details

### Protocol Layer

#### `src/protocol/protocol.x` âš™ï¸ Hand-Written

**Purpose**: Defines the RPC interface in XDR language

**Key Components**:
```c
// Maximum buffer size for read/write operations
const MAX_BUFFER_SIZE = 1048576;  /* 1 MB */

// Program and version identifiers
const SYSCALL_PROG = 0x20000001;
const SYSCALL_VERS = 1;

// Request/response structures for each syscall
struct open_request {
    string path<4096>;      // File path (max 4096 bytes)
    int flags;              // open() flags (O_RDONLY, etc.)
    unsigned int mode;      // Permissions (0644, etc.)
};

struct open_response {
    int fd;                 // File descriptor (client-side)
    int result;             // Return value (-1 on error)
    int err;                // errno value
};

// ... similar for read, write, close

// RPC program definition
program SYSCALL_PROG {
    version SYSCALL_VERS {
        open_response SYSCALL_OPEN(open_request) = 1;
        close_response SYSCALL_CLOSE(close_request) = 2;
        read_response SYSCALL_READ(read_request) = 3;
        write_response SYSCALL_WRITE(write_request) = 4;
    } = 1;
} = 0x20000001;
```

**Why This Matters**:
- This is the single source of truth for the RPC interface
- Changing this file requires regenerating all protocol files with `make rpc_gen`
- Both client and server must use the same protocol.x

**Regeneration**:
```bash
cd src/protocol && rpcgen -C protocol.x
```

---

#### `src/protocol/protocol.h` ğŸ¤– Generated (DO NOT EDIT)

**Generated By**: `rpcgen -C protocol.x`

**Purpose**: C header with structure definitions and function declarations

**Key Contents**:
```c
// Structure definitions (matching protocol.x)
struct open_request {
    char *path;
    int flags;
    u_int mode;
};
typedef struct open_request open_request;

struct open_response {
    int fd;
    int result;
    int err;
};
typedef struct open_response open_response;

// XDR function declarations (implemented in protocol_xdr.c)
extern bool_t xdr_open_request(XDR *, open_request*);
extern bool_t xdr_open_response(XDR *, open_response*);

// RPC client stub declarations (implemented in protocol_clnt.c)
extern open_response *syscall_open_1(open_request *, CLIENT *);
extern close_response *syscall_close_1(close_request *, CLIENT *);
extern read_response *syscall_read_1(read_request *, CLIENT *);
extern write_response *syscall_write_1(write_request *, CLIENT *);

// Program and procedure numbers
#define SYSCALL_PROG 0x20000001
#define SYSCALL_VERS 1
#define SYSCALL_OPEN 1
#define SYSCALL_CLOSE 2
#define SYSCALL_READ 3
#define SYSCALL_WRITE 4
```

**Used By**: All source files that interact with RPC (server, client, interceptors)

---

#### `src/protocol/protocol_xdr.c` ğŸ¤– Generated (DO NOT EDIT)

**Generated By**: `rpcgen -C protocol.x`

**Purpose**: Implements XDR serialization/deserialization for all structures

**Example Function**:
```c
bool_t xdr_open_request(XDR *xdrs, open_request *objp) {
    // Serialize/deserialize the path string (max 4096 bytes)
    if (!xdr_string(xdrs, &objp->path, 4096))
        return FALSE;

    // Serialize/deserialize flags (int)
    if (!xdr_int(xdrs, &objp->flags))
        return FALSE;

    // Serialize/deserialize mode (unsigned int)
    if (!xdr_u_int(xdrs, &objp->mode))
        return FALSE;

    return TRUE;
}
```

**How It Works**:
- Same function handles both encoding (clientâ†’server) and decoding (serverâ†’client)
- XDR stream direction determined by XDR object passed in
- Returns FALSE on any serialization error

**Used By**: RPC stubs and dispatcher (automatically called by RPC library)

---

#### `src/protocol/protocol_clnt.c` ğŸ¤– Generated (DO NOT EDIT)

**Generated By**: `rpcgen -C protocol.x`

**Purpose**: Client-side RPC stub functions

**Example Stub**:
```c
open_response *syscall_open_1(open_request *argp, CLIENT *clnt) {
    static open_response clnt_res;  // Static storage for result

    // Clear previous result
    memset((char *)&clnt_res, 0, sizeof(clnt_res));

    // Make RPC call
    if (clnt_call(clnt, SYSCALL_OPEN,
                  (xdrproc_t) xdr_open_request, (caddr_t) argp,
                  (xdrproc_t) xdr_open_response, (caddr_t) &clnt_res,
                  TIMEOUT) != RPC_SUCCESS) {
        return (NULL);  // RPC call failed
    }

    return (&clnt_res);  // Success
}
```

**What Happens Inside `clnt_call()`**:
1. Serializes `argp` using `xdr_open_request()`
2. Sends request over network
3. Waits for response
4. Deserializes response using `xdr_open_response()`
5. Returns RPC_SUCCESS or error code

**Used By**: Interceptor functions (intercept_open.h, etc.)

---

#### `src/protocol/protocol_svc.c` ğŸ¤– Generated + Modified

**Generated By**: `rpcgen -C protocol.x`

**Modified By**: Makefile `sed` commands (automated)

**Purpose**: Server-side RPC dispatcher

**Key Function**:
```c
void syscall_prog_1(struct svc_req *rqstp, register SVCXPRT *transp) {
    union {
        open_request syscall_open_1_arg;
        close_request syscall_close_1_arg;
        read_request syscall_read_1_arg;
        write_request syscall_write_1_arg;
    } argument;

    char *result;
    xdrproc_t _xdr_argument, _xdr_result;
    char *(*local)(char *, struct svc_req *);

    // Determine which procedure was called
    switch (rqstp->rq_proc) {
    case SYSCALL_OPEN:
        _xdr_argument = (xdrproc_t) xdr_open_request;
        _xdr_result = (xdrproc_t) xdr_open_response;
        local = (char *(*)(char *, struct svc_req *)) syscall_open_1_svc;
        break;

    case SYSCALL_CLOSE:
        // ... similar
        break;

    // ... cases for READ, WRITE

    default:
        svcerr_noproc(transp);  // Unknown procedure
        return;
    }

    // Deserialize arguments
    memset((char *)&argument, 0, sizeof(argument));
    if (!svc_getargs(transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
        svcerr_decode(transp);
        return;
    }

    // Call the actual server implementation
    result = (*local)((char *)&argument, rqstp);

    // Serialize and send response
    if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
        svcerr_systemerr(transp);
    }

    // Free arguments
    if (!svc_freeargs(transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
        fprintf(stderr, "unable to free arguments");
        exit(1);
    }
}
```

**Modifications Applied**:
1. **Wrapped auto-generated main()** with `#ifndef RPC_SVC_FG` guard (allows custom main)
2. **Made `syscall_prog_1` non-static** (so custom main can call it)

**Used By**: `rpc_server.c:main()` calls `svc_register(..., syscall_prog_1, ...)`

---

### Server Layer

#### `src/rpc_server.c` âš™ï¸ Hand-Written

**Purpose**: RPC server executable with syscall implementations and FD mapping

**Key Components**:

##### 1. FD Mapping Table
```c
#define MAX_FDS 1024

static int fd_mapping[MAX_FDS];  // client_fd â†’ server_fd
static int next_client_fd = 3;   // Start after stdin/stdout/stderr

void init_fd_mapping(void) {
    for (int i = 0; i < MAX_FDS; i++) {
        fd_mapping[i] = -1;  // -1 = unmapped
    }
}

int add_fd_mapping(int server_fd) {
    int client_fd = next_client_fd++;
    fd_mapping[client_fd] = server_fd;
    printf("[Server] FD Mapping: client_fd=%d â†’ server_fd=%d\n",
           client_fd, server_fd);
    return client_fd;
}

void remove_fd_mapping(int client_fd) {
    if (client_fd >= 0 && client_fd < MAX_FDS) {
        int server_fd = fd_mapping[client_fd];
        printf("[Server] Removing FD Mapping: client_fd=%d â†’ server_fd=%d\n",
               client_fd, server_fd);
        fd_mapping[client_fd] = -1;
    }
}

int get_server_fd(int client_fd) {
    if (client_fd < 0 || client_fd >= MAX_FDS) {
        return -1;
    }
    return fd_mapping[client_fd];
}
```

##### 2. Server Procedure Implementations

**open() Handler**:
```c
open_response* syscall_open_1_svc(open_request *req, struct svc_req *rqstp) {
    static open_response res;

    printf("[Server] Handling open('%s', flags=0x%x, mode=0%o)\n",
           req->path, req->flags, req->mode);

    // Execute the actual syscall
    int server_fd = open(req->path, req->flags, req->mode);

    if (server_fd >= 0) {
        // Success: create FD mapping
        int client_fd = add_fd_mapping(server_fd);
        res.fd = client_fd;
        res.result = client_fd;
        res.err = 0;
    } else {
        // Failure: return error
        res.fd = -1;
        res.result = -1;
        res.err = errno;
        printf("[Server] open() failed: %s\n", strerror(errno));
    }

    return &res;
}
```

**close() Handler**:
```c
close_response* syscall_close_1_svc(close_request *req, struct svc_req *rqstp) {
    static close_response res;

    int server_fd = get_server_fd(req->fd);
    if (server_fd < 0) {
        res.result = -1;
        res.err = EBADF;  // Bad file descriptor
        return &res;
    }

    printf("[Server] Handling close(client_fd=%d, server_fd=%d)\n",
           req->fd, server_fd);

    int result = close(server_fd);

    res.result = result;
    res.err = (result < 0) ? errno : 0;

    if (result >= 0) {
        remove_fd_mapping(req->fd);  // Cleanup mapping
    }

    return &res;
}
```

**read() Handler**:
```c
read_response* syscall_read_1_svc(read_request *req, struct svc_req *rqstp) {
    static read_response res;
    static char buffer[MAX_BUFFER_SIZE];  // Static storage for data

    int server_fd = get_server_fd(req->fd);
    if (server_fd < 0) {
        res.result = -1;
        res.err = EBADF;
        res.data.data_len = 0;
        res.data.data_val = NULL;
        return &res;
    }

    size_t count = (req->count > MAX_BUFFER_SIZE) ? MAX_BUFFER_SIZE : req->count;

    ssize_t bytes_read = read(server_fd, buffer, count);

    if (bytes_read >= 0) {
        res.data.data_val = buffer;        // Point to buffer
        res.data.data_len = bytes_read;    // Actual bytes read
        res.result = bytes_read;
        res.err = 0;
    } else {
        res.data.data_val = NULL;
        res.data.data_len = 0;
        res.result = -1;
        res.err = errno;
    }

    return &res;
}
```

**write() Handler**:
```c
write_response* syscall_write_1_svc(write_request *req, struct svc_req *rqstp) {
    static write_response res;

    int server_fd = get_server_fd(req->fd);
    if (server_fd < 0) {
        res.result = -1;
        res.err = EBADF;
        return &res;
    }

    ssize_t bytes_written = write(server_fd, req->data.data_val, req->data.data_len);

    res.result = bytes_written;
    res.err = (bytes_written < 0) ? errno : 0;

    return &res;
}
```

##### 3. Main Function (Transport Setup)

```c
int main(int argc, char *argv[]) {
    init_fd_mapping();

    transport_type_t transport = get_transport_type();

    if (transport == TRANSPORT_UNIX) {
        // UNIX socket implementation
        // (See full code in ARCHITECTURE.md)
        // Creates socket, binds, listens, accepts in loop
    } else {
        // TCP socket implementation
        SVCXPRT *transp = svctcp_create(RPC_ANYSOCK, 0, 0);
        if (transp == NULL) {
            fprintf(stderr, "Error: cannot create TCP service\n");
            exit(1);
        }

        if (!svc_register(transp, SYSCALL_PROG, SYSCALL_VERS,
                         syscall_prog_1, IPPROTO_TCP)) {
            fprintf(stderr, "Error: unable to register (SYSCALL_PROG, SYSCALL_VERS, tcp)\n");
            exit(1);
        }

        printf("[Server] Listening on TCP (requires rpcbind)...\n");
        svc_run();  // Never returns
    }

    return 0;
}
```

**Compilation**:
```bash
gcc -o build/syscall_server src/rpc_server.c \
    src/protocol/protocol_xdr.c src/protocol/protocol_svc.c \
    $(pkg-config --cflags --libs libtirpc) -DRPC_SVC_FG
```

Note: `-DRPC_SVC_FG` disables the auto-generated main() in protocol_svc.c

---

### Client Layer

#### `src/rpc_client.c` âš™ï¸ Hand-Written

**Purpose**: Manages RPC client connections (one per thread)

**Key Components**:

##### Thread-Local Storage
```c
static __thread CLIENT *rpc_client = NULL;      // RPC client handle
static __thread int in_rpc_init = 0;            // Initialization guard
static __thread int rpc_in_progress = 0;        // Global interception guard
```

##### Main Function: `get_rpc_client()`
```c
CLIENT *get_rpc_client(void) {
    // Return existing connection if available
    if (rpc_client != NULL) {
        return rpc_client;
    }

    // Prevent recursive initialization
    if (in_rpc_init) {
        return NULL;
    }

    in_rpc_init = 1;
    rpc_in_progress = 1;  // CRITICAL: disable all interceptors

    transport_type_t transport = get_transport_type();

    if (transport == TRANSPORT_UNIX) {
        // UNIX socket connection
        int sock = socket(AF_UNIX, SOCK_STREAM, 0);
        if (sock < 0) {
            goto cleanup;
        }

        struct sockaddr_un server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sun_family = AF_UNIX;
        strncpy(server_addr.sun_path, UNIX_SOCKET_PATH, ...);

        if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
            close(sock);
            goto cleanup;
        }

        // Create RPC client from connected socket
        struct netbuf svcaddr;
        svcaddr.len = svcaddr.maxlen = sizeof(server_addr);
        svcaddr.buf = (char *)&server_addr;

        rpc_client = clnt_vc_create(sock, &svcaddr, SYSCALL_PROG, SYSCALL_VERS, 0, 0);
    } else {
        // TCP socket connection (requires rpcbind)
        rpc_client = clnt_create(TCP_HOST, SYSCALL_PROG, SYSCALL_VERS, "tcp");
    }

cleanup:
    rpc_in_progress = 0;  // Re-enable interceptors
    in_rpc_init = 0;

    return rpc_client;
}
```

##### Helper Functions
```c
void rpc_in_progress = int value) {
    rpc_in_progress = value;
}

int is_rpc_in_progress(void) {
    return rpc_in_progress;
}
```

**Why These Helpers?**
- Accessed by all interceptors to check if RPC is in progress
- Prevents recursive interception during RPC library's internal syscalls

---

#### `src/intercept_client.c` âš™ï¸ Hand-Written (Entry Point)

**Purpose**: Shared library entry point, includes all interceptors

**Contents**:
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>

// Include protocol definitions
#include "protocol/protocol.h"

// Include RPC client
#include "rpc_client.c"

// Include all interceptors
#include "intercept/intercept_open.h"
#include "intercept/intercept_close.h"
#include "intercept/intercept_read.h"
#include "intercept/intercept_write.h"
```

**Why This Design?**
- Single compilation unit for the shared library
- All interceptors in header files (simplifies build)
- RPC client code inlined (single .so file)

**Compilation**:
```bash
gcc -shared -fPIC -o build/intercept.so src/intercept_client.c \
    src/protocol/protocol_xdr.c src/protocol/protocol_clnt.c \
    $(pkg-config --cflags --libs libtirpc)
```

---

### Interceptor Layer

Each interceptor follows the same pattern. They are header files included by `intercept_client.c`.

#### `src/intercept/intercept_open.h` âš™ï¸ Hand-Written

**Purpose**: Intercepts `open()` and `open64()` syscalls

**Structure**:
```c
#ifndef INTERCEPT_OPEN_H
#define INTERCEPT_OPEN_H

#include <fcntl.h>
#include <stdarg.h>
#include <sys/syscall.h>

// Thread-local reentry guard
static __thread int in_open_intercept = 0;

// Intercept open()
int open(const char *pathname, int flags, ...) {
    // Extract mode argument (variadic)
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }

    // Guard: prevent recursion
    if (in_open_intercept || is_rpc_in_progress()) {
        return syscall(SYS_open, pathname, flags, mode);
    }

    in_open_intercept = 1;

    // Get RPC client connection
    CLIENT *client = get_rpc_client();

    int result = -1;
    if (client != NULL) {
        // Package arguments
        open_request req = {
            .path = (char*)pathname,
            .flags = flags,
            .mode = mode
        };

        // Make RPC call (with guard)
        rpc_in_progress = 1;
        open_response *res = syscall_open_1(&req, client);
        rpc_in_progress = 0;

        if (res != NULL) {
            result = res->result;
            errno = res->err;
        }
    } else {
        // Fallback to direct syscall
        result = syscall(SYS_open, pathname, flags, mode);
    }

    in_open_intercept = 0;
    return result;
}

// Intercept open64() (similar implementation)
int open64(const char *pathname, int flags, ...) {
    // ... similar to open()
}

#endif // INTERCEPT_OPEN_H
```

**Key Points**:
- Guards against recursion (per-syscall + global RPC flag)
- Handles variadic arguments (mode only needed with O_CREAT)
- Fallback to direct syscall if RPC unavailable

#### Other Interceptors

**`src/intercept/intercept_close.h`** - Similar pattern:
```c
static __thread int in_close_intercept = 0;

int close(int fd) {
    if (in_close_intercept || is_rpc_in_progress()) {
        return syscall(SYS_close, fd);
    }
    // ... RPC call to syscall_close_1()
}
```

**`src/intercept/intercept_read.h`** - Similar pattern:
```c
static __thread int in_read_intercept = 0;

ssize_t read(int fd, void *buf, size_t count) {
    if (in_read_intercept || is_rpc_in_progress()) {
        return syscall(SYS_read, fd, buf, count);
    }
    // ... RPC call to syscall_read_1()
    // Copy data from response to buf
}
```

**`src/intercept/intercept_write.h`** - Similar pattern:
```c
static __thread int in_write_intercept = 0;

ssize_t write(int fd, const void *buf, size_t count) {
    if (in_write_intercept || is_rpc_in_progress()) {
        return syscall(SYS_write, fd, buf, count);
    }
    // ... RPC call to syscall_write_1()
}
```

---

### Configuration

#### `src/transport_config.h` âš™ï¸ Hand-Written

**Purpose**: Single place to configure transport settings

**Contents**:
```c
#ifndef TRANSPORT_CONFIG_H
#define TRANSPORT_CONFIG_H

#include <string.h>
#include <strings.h>
#include <stdlib.h>

typedef enum {
    TRANSPORT_UNIX,  // UNIX domain sockets (default)
    TRANSPORT_TCP    // TCP sockets
} transport_type_t;

// UNIX socket configuration
#define UNIX_SOCKET_PATH "/tmp/p3_tb"

// TCP socket configuration
#define TCP_HOST "localhost"
#define TCP_PORT 9999

// Determine transport type from environment variable
static inline transport_type_t get_transport_type(void) {
    const char *env = getenv("RPC_TRANSPORT");
    if (env != NULL && strcasecmp(env, "tcp") == 0) {
        return TRANSPORT_TCP;
    }
    return TRANSPORT_UNIX;  // Default
}

#endif // TRANSPORT_CONFIG_H
```

**Usage**:
```bash
# Use UNIX sockets (default)
./build/syscall_server
LD_PRELOAD=./build/intercept.so ./program

# Use TCP sockets
RPC_TRANSPORT=tcp ./build/syscall_server
RPC_TRANSPORT=tcp LD_PRELOAD=./build/intercept.so ./program
```

**Included By**: `rpc_server.c` and `rpc_client.c`

---

### Test Program

#### `src/program.c` âš™ï¸ Hand-Written

**Purpose**: Comprehensive test program to verify all syscalls

**Test Structure**:
```c
int main() {
    const char *test_file = "/tmp/p3_tb_test.txt";
    const char *test_data = "Hello from P3_TB syscall interception system! Test data.";
    size_t data_len = strlen(test_data);

    printf("=== Starting P3_TB Syscall Interception Tests ===\n\n");

    // Test 1: open() for writing
    printf("[Test 1] Opening file for writing...\n");
    int fd = open(test_file, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    assert(fd >= 0);
    printf("[Test 1] PASS - fd=%d\n\n", fd);

    // Test 2: write()
    printf("[Test 2] Writing data...\n");
    ssize_t written = write(fd, test_data, data_len);
    assert(written == data_len);
    printf("[Test 2] PASS - wrote %zd bytes\n\n", written);

    // Test 3: close()
    printf("[Test 3] Closing write fd...\n");
    int ret = close(fd);
    assert(ret == 0);
    printf("[Test 3] PASS\n\n");

    // Test 4: open() for reading
    printf("[Test 4] Opening file for reading...\n");
    fd = open(test_file, O_RDONLY);
    assert(fd >= 0);
    printf("[Test 4] PASS - fd=%d\n\n", fd);

    // Test 5: read()
    printf("[Test 5] Reading data...\n");
    char buffer[1024];
    ssize_t bytes_read = read(fd, buffer, sizeof(buffer));
    assert(bytes_read == data_len);
    buffer[bytes_read] = '\0';
    printf("[Test 5] PASS - read %zd bytes\n\n", bytes_read);

    // Test 6: data integrity
    printf("[Test 6] Verifying data integrity...\n");
    assert(strcmp(buffer, test_data) == 0);
    printf("[Test 6] PASS - data matches\n\n");

    // Test 7: close()
    printf("[Test 7] Closing read fd...\n");
    ret = close(fd);
    assert(ret == 0);
    printf("[Test 7] PASS\n\n");

    printf("=== Test Result: ALL TESTS PASSED ===\n");
    return 0;
}
```

**Compilation**:
```bash
gcc -o build/program src/program.c
```

**Usage**:
```bash
# With interception
LD_PRELOAD=./build/intercept.so ./build/program

# Without interception (direct syscalls)
./build/program
```

---

## Build System

### Makefile

**Key Targets**:

```makefile
# Build everything
all: server client program

# Generate RPC protocol files from protocol.x
rpc_gen:
    cd src/protocol && rpcgen -C protocol.x
    # Fix generated code (wrap main, make dispatcher non-static)
    sed -i '/^int$/,/^}$$/{/^int$$/i\#ifndef RPC_SVC_FG\n;/^}$$/a\#endif\n}' src/protocol/protocol_svc.c
    sed -i 's/^static void syscall_prog_1/void syscall_prog_1/' src/protocol/protocol_svc.c

# Build server
server: rpc_gen
    gcc -o build/syscall_server src/rpc_server.c \
        src/protocol/protocol_xdr.c src/protocol/protocol_svc.c \
        $(CFLAGS) $(LDFLAGS) -DRPC_SVC_FG

# Build client shared library
client: rpc_gen
    gcc -shared -fPIC -o build/intercept.so src/intercept_client.c \
        src/protocol/protocol_xdr.c src/protocol/protocol_clnt.c \
        $(CFLAGS) $(LDFLAGS)

# Build test program
program:
    gcc -o build/program src/program.c

# Clean
clean:
    rm -f build/* src/protocol/protocol.h src/protocol/protocol_xdr.c \
          src/protocol/protocol_clnt.c src/protocol/protocol_svc.c
```

**Dependencies**:
- libtirpc-dev (RPC library)
- pkg-config (for finding libtirpc)
- rpcgen (protocol compiler)

---

## Module Dependencies

```
program.c
    â†“ (LD_PRELOAD loads)
intercept_client.c
    â”œâ”€â†’ intercept_open.h
    â”œâ”€â†’ intercept_close.h
    â”œâ”€â†’ intercept_read.h
    â”œâ”€â†’ intercept_write.h
    â”‚       â†“ (all call)
    â”œâ”€â†’ rpc_client.c
    â”‚       â†“ (uses)
    â””â”€â†’ transport_config.h

rpc_client.c
    â”œâ”€â†’ protocol_clnt.c (generated)
    â”œâ”€â†’ protocol.h (generated)
    â””â”€â†’ transport_config.h

rpc_server.c
    â”œâ”€â†’ protocol_svc.c (generated)
    â”œâ”€â†’ protocol.h (generated)
    â””â”€â†’ transport_config.h

protocol_clnt.c (generated)
    â”œâ”€â†’ protocol.h (generated)
    â””â”€â†’ protocol_xdr.c (generated)

protocol_svc.c (generated)
    â”œâ”€â†’ protocol.h (generated)
    â””â”€â†’ protocol_xdr.c (generated)

protocol.h, protocol_xdr.c, protocol_clnt.c, protocol_svc.c
    â†‘ (all generated from)
protocol.x
```

## File Summary Table

| File | Type | Lines | Purpose |
|------|------|-------|---------|
| `src/protocol/protocol.x` | Hand-written | ~100 | RPC interface definition |
| `src/protocol/protocol.h` | Generated | ~200 | Structure definitions |
| `src/protocol/protocol_xdr.c` | Generated | ~300 | XDR serialization |
| `src/protocol/protocol_clnt.c` | Generated | ~200 | Client RPC stubs |
| `src/protocol/protocol_svc.c` | Generated + Mod | ~400 | Server RPC dispatcher |
| `src/rpc_server.c` | Hand-written | ~350 | Server implementation |
| `src/rpc_client.c` | Hand-written | ~150 | Client connection manager |
| `src/intercept_client.c` | Hand-written | ~20 | Shared library entry |
| `src/intercept/intercept_open.h` | Hand-written | ~150 | open() interceptor |
| `src/intercept/intercept_close.h` | Hand-written | ~80 | close() interceptor |
| `src/intercept/intercept_read.h` | Hand-written | ~120 | read() interceptor |
| `src/intercept/intercept_write.h` | Hand-written | ~100 | write() interceptor |
| `src/transport_config.h` | Hand-written | ~40 | Transport configuration |
| `src/program.c` | Hand-written | ~100 | Test program |
| `Makefile` | Hand-written | ~80 | Build system |

**Total**: ~2,390 lines (excluding blank lines and comments)

**Key Insight**: Only ~1,090 lines hand-written, ~1,300 generated by rpcgen!

---

**Next**: [05_TRANSPORT_LAYER.md](./05_TRANSPORT_LAYER.md) - Transport implementation details

**Prev**: [02_ARCHITECTURE.md](./02_ARCHITECTURE.md) - System architecture
